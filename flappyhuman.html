import React, { useEffect, useRef, useState } from "react";
import { motion } from "framer-motion";

const GRAVITY = 0.5;
const JUMP = -10;
const PIPE_WIDTH = 60;
const PIPE_GAP = 150;
const GAME_WIDTH = 800;
const GAME_HEIGHT = 600;

export default function FlappyHumanGame() {
  const [humanY, setHumanY] = useState(GAME_HEIGHT / 2);
  const [velocity, setVelocity] = useState(0);
  const [pipes, setPipes] = useState([]);
  const [score, setScore] = useState(0);
  const [gameOver, setGameOver] = useState(false);
  const gameRef = useRef();

  useEffect(() => {
    if (gameOver) return;

    const interval = setInterval(() => {
      setVelocity((v) => v + GRAVITY);
      setHumanY((y) => y + velocity);

      setPipes((prevPipes) => {
        const newPipes = prevPipes
          .map((pipe) => ({ ...pipe, x: pipe.x - 5 }))
          .filter((pipe) => pipe.x + PIPE_WIDTH > 0);

        if (newPipes.length === 0 || newPipes[newPipes.length - 1].x < GAME_WIDTH - 300) {
          const topHeight = Math.random() * (GAME_HEIGHT - PIPE_GAP - 100) + 50;
          newPipes.push({ x: GAME_WIDTH, topHeight });
        }

        newPipes.forEach((pipe) => {
          if (
            pipe.x + PIPE_WIDTH < 100 &&
            !pipe.passed
          ) {
            pipe.passed = true;
            setScore((s) => s + 1);
          }
        });

        return newPipes;
      });

      // Collision detection
      pipes.forEach((pipe) => {
        if (
          100 < pipe.x + PIPE_WIDTH &&
          100 + 40 > pipe.x &&
          (humanY < pipe.topHeight || humanY + 40 > pipe.topHeight + PIPE_GAP)
        ) {
          setGameOver(true);
        }
      });

      if (humanY < 0 || humanY > GAME_HEIGHT) {
        setGameOver(true);
      }
    }, 30);

    return () => clearInterval(interval);
  }, [velocity, humanY, pipes, gameOver]);

  const jump = () => {
    if (!gameOver) {
      setVelocity(JUMP);
    } else {
      setHumanY(GAME_HEIGHT / 2);
      setVelocity(0);
      setPipes([]);
      setScore(0);
      setGameOver(false);
    }
  };

  return (
    <div
      ref={gameRef}
      onClick={jump}
      className="relative w-[800px] h-[600px] bg-sky-300 overflow-hidden border-4 border-black cursor-pointer"
    >
      <motion.div
        className="absolute left-[100px] w-[40px] h-[40px] rounded-full bg-yellow-500"
        animate={{ y: humanY }}
        transition={{ ease: "easeOut", duration: 0.1 }}
      >
        {/* Animated Human */}
        <div className="w-full h-full bg-[url('/human-sprite.gif')] bg-cover" />
      </motion.div>
      {pipes.map((pipe, i) => (
        <React.Fragment key={i}>
          <div
            className="absolute bg-green-700"
            style={{
              left: pipe.x,
              top: 0,
              width: PIPE_WIDTH,
              height: pipe.topHeight,
            }}
          />
          <div
            className="absolute bg-green-700"
            style={{
              left: pipe.x,
              top: pipe.topHeight + PIPE_GAP,
              width: PIPE_WIDTH,
              height: GAME_HEIGHT - pipe.topHeight - PIPE_GAP,
            }}
          />
        </React.Fragment>
      ))}
      <div className="absolute top-4 left-4 text-2xl font-bold text-white">Score: {score}</div>
      {gameOver && (
        <div className="absolute inset-0 flex items-center justify-center text-4xl font-bold text-red-700">
          Game Over! Click to Restart
        </div>
      )}
    </div>
  );
}
